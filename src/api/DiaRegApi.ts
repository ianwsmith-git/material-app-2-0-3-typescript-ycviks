/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { authProvider } from '../auth/AuthProvider';

const defaultOptions = {
    headers: {
        // "Authorization": "",
        // 'Access-Control-Allow-Origin': '*',
        // 'Access-Control-Allow-Methods': 'GET,PUT,POST,DELETE,PATCH,OPTIONS'
    }
}

const _AxiosInstance = axios.create(defaultOptions);

const getToken = async () => {

    //let authProvider = new AuthProvider();
    // await authProvider.getAccessToken();

}

_AxiosInstance.interceptors.request.use(async config => {
    //let authProvider = new AuthProvider();
    //const token = await authProvider.getApiToken();
    // config.headers["Authorization"] = `Bearer ${token}`;


    return config;
},
    error => {
        Promise.reject(error)
    });

export class DiaRegWebApiClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor() {




        this.instance = _AxiosInstance; // instance ? instance : axios.create(defaultOptions);
        //this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

        this.baseUrl = process.env.REACT_APP_API_URL!
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getDoctors(body: ListSearch | undefined, cancelToken?: CancelToken | undefined): Promise<PersonPagedResponse> {
        let url_ = this.baseUrl + "/api/Doctors/GetDoctors";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDoctors(_response);
        });
    }

    protected processGetDoctors(response: AxiosResponse): Promise<PersonPagedResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = PersonPagedResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PersonPagedResponse>(<any>null);
    }

    /**
     * @param doctorId (optional) 
     * @return Success
     */
    getDoctor(doctorId: number | undefined, cancelToken?: CancelToken | undefined): Promise<PersonResponse> {
        let url_ = this.baseUrl + "/api/Doctors/GetDoctor?";
        if (doctorId === null)
            throw new Error("The parameter 'doctorId' cannot be null.");
        else if (doctorId !== undefined)
            url_ += "doctorId=" + encodeURIComponent("" + doctorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDoctor(_response);
        });
    }

    protected processGetDoctor(response: AxiosResponse): Promise<PersonResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = PersonResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PersonResponse>(<any>null);
    }

    /**
     * @param doctorId (optional) 
     * @return Success
     */
    getDoctorLocations(doctorId: number | undefined, cancelToken?: CancelToken | undefined): Promise<PersonAddressListResponse> {
        let url_ = this.baseUrl + "/api/Doctors/GetDoctorLocations?";
        if (doctorId === null)
            throw new Error("The parameter 'doctorId' cannot be null.");
        else if (doctorId !== undefined)
            url_ += "doctorId=" + encodeURIComponent("" + doctorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDoctorLocations(_response);
        });
    }

    protected processGetDoctorLocations(response: AxiosResponse): Promise<PersonAddressListResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = PersonAddressListResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PersonAddressListResponse>(<any>null);
    }

    /**
     * @param locationId (optional) 
     * @return Success
     */
    getDoctorLocation(locationId: number | undefined, cancelToken?: CancelToken | undefined): Promise<PersonAddressResponse> {
        let url_ = this.baseUrl + "/api/Doctors/GetDoctorLocation?";
        if (locationId === null)
            throw new Error("The parameter 'locationId' cannot be null.");
        else if (locationId !== undefined)
            url_ += "locationId=" + encodeURIComponent("" + locationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDoctorLocation(_response);
        });
    }

    protected processGetDoctorLocation(response: AxiosResponse): Promise<PersonAddressResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = PersonAddressResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PersonAddressResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDoctor(body: Person | undefined, cancelToken?: CancelToken | undefined): Promise<Response> {
        let url_ = this.baseUrl + "/api/Doctors/UpdateDoctor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateDoctor(_response);
        });
    }

    protected processUpdateDoctor(response: AxiosResponse): Promise<Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Response>(<any>null);
    }

    /**
     * @return Success
     */
    newDoctor(cancelToken?: CancelToken | undefined): Promise<PersonResponse> {
        let url_ = this.baseUrl + "/api/Doctors/NewDoctor";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processNewDoctor(_response);
        });
    }

    protected processNewDoctor(response: AxiosResponse): Promise<PersonResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = PersonResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PersonResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addDoctor(body: Person | undefined, cancelToken?: CancelToken | undefined): Promise<Int32Response> {
        let url_ = this.baseUrl + "/api/Doctors/AddDoctor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddDoctor(_response);
        });
    }

    protected processAddDoctor(response: AxiosResponse): Promise<Int32Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Int32Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDoctorLocation(body: PersonAddress | undefined, cancelToken?: CancelToken | undefined): Promise<Response> {
        let url_ = this.baseUrl + "/api/Doctors/UpdateDoctorLocation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateDoctorLocation(_response);
        });
    }

    protected processUpdateDoctorLocation(response: AxiosResponse): Promise<Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addDoctorLocation(body: PersonAddress | undefined, cancelToken?: CancelToken | undefined): Promise<Int32Response> {
        let url_ = this.baseUrl + "/api/Doctors/AddDoctorLocation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddDoctorLocation(_response);
        });
    }

    protected processAddDoctorLocation(response: AxiosResponse): Promise<Int32Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Int32Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteDoctorLocation(body: number | undefined, cancelToken?: CancelToken | undefined): Promise<Response> {
        let url_ = this.baseUrl + "/api/Doctors/DeleteDoctorLocation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteDoctorLocation(_response);
        });
    }

    protected processDeleteDoctorLocation(response: AxiosResponse): Promise<Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteDoctor(body: number | undefined, cancelToken?: CancelToken | undefined): Promise<Response> {
        let url_ = this.baseUrl + "/api/Doctors/DeleteDoctor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeleteDoctor(_response);
        });
    }

    protected processDeleteDoctor(response: AxiosResponse): Promise<Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getPatients(body: ListSearch | undefined, cancelToken?: CancelToken | undefined): Promise<PatientPagedResponse> {
        let url_ = this.baseUrl + "/api/Patients/GetPatients";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPatients(_response);
        });
    }

    protected processGetPatients(response: AxiosResponse): Promise<PatientPagedResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = PatientPagedResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PatientPagedResponse>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPatient(id: number | undefined, cancelToken?: CancelToken | undefined): Promise<PatientResponse> {
        let url_ = this.baseUrl + "/api/Patients/GetPatient?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPatient(_response);
        });
    }

    protected processGetPatient(response: AxiosResponse): Promise<PatientResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = PatientResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PatientResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePatient(body: Patient | undefined, cancelToken?: CancelToken | undefined): Promise<Response> {
        let url_ = this.baseUrl + "/api/Patients/UpdatePatient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePatient(_response);
        });
    }

    protected processUpdatePatient(response: AxiosResponse): Promise<Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addPatient(body: Patient | undefined, cancelToken?: CancelToken | undefined): Promise<Int32Response> {
        let url_ = this.baseUrl + "/api/Patients/AddPatient";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddPatient(_response);
        });
    }

    protected processAddPatient(response: AxiosResponse): Promise<Int32Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Int32Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32Response>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVisits(id: number | undefined, cancelToken?: CancelToken | undefined): Promise<VisitPagedResponse> {
        let url_ = this.baseUrl + "/api/Patients/GetVisits?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetVisits(_response);
        });
    }

    protected processGetVisits(response: AxiosResponse): Promise<VisitPagedResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = VisitPagedResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VisitPagedResponse>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVisit(id: number | undefined, cancelToken?: CancelToken | undefined): Promise<VisitResponse> {
        let url_ = this.baseUrl + "/api/Patients/GetVisit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetVisit(_response);
        });
    }

    protected processGetVisit(response: AxiosResponse): Promise<VisitResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = VisitResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VisitResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateVisit(body: Visit | undefined, cancelToken?: CancelToken | undefined): Promise<Response> {
        let url_ = this.baseUrl + "/api/Patients/UpdateVisit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateVisit(_response);
        });
    }

    protected processUpdateVisit(response: AxiosResponse): Promise<Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addVisit(body: Visit | undefined, cancelToken?: CancelToken | undefined): Promise<Int32Response> {
        let url_ = this.baseUrl + "/api/Patients/AddVisit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddVisit(_response);
        });
    }

    protected processAddVisit(response: AxiosResponse): Promise<Int32Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Int32Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32Response>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContacts(id: number | undefined, cancelToken?: CancelToken | undefined): Promise<ContactPagedResponse> {
        let url_ = this.baseUrl + "/api/Patients/GetContacts?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetContacts(_response);
        });
    }

    protected processGetContacts(response: AxiosResponse): Promise<ContactPagedResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = ContactPagedResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContactPagedResponse>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContact(id: number | undefined, cancelToken?: CancelToken | undefined): Promise<ContactResponse> {
        let url_ = this.baseUrl + "/api/Patients/GetContact?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetContact(_response);
        });
    }

    protected processGetContact(response: AxiosResponse): Promise<ContactResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = ContactResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContactResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateContact(body: Contact | undefined, cancelToken?: CancelToken | undefined): Promise<Response> {
        let url_ = this.baseUrl + "/api/Patients/UpdateContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdateContact(_response);
        });
    }

    protected processUpdateContact(response: AxiosResponse): Promise<Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Response>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addContact(body: Contact | undefined, cancelToken?: CancelToken | undefined): Promise<Int32Response> {
        let url_ = this.baseUrl + "/api/Patients/AddContact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddContact(_response);
        });
    }

    protected processAddContact(response: AxiosResponse): Promise<Int32Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Int32Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32Response>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPatientSurveys(id: number | undefined, cancelToken?: CancelToken | undefined): Promise<PatientSurveyPagedResponse> {
        let url_ = this.baseUrl + "/api/Patients/GetPatientSurveys?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPatientSurveys(_response);
        });
    }

    protected processGetPatientSurveys(response: AxiosResponse): Promise<PatientSurveyPagedResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = PatientSurveyPagedResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PatientSurveyPagedResponse>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPatientSurvey(id: number | undefined, cancelToken?: CancelToken | undefined): Promise<StringResponse> {
        let url_ = this.baseUrl + "/api/Patients/GetPatientSurvey?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPatientSurvey(_response);
        });
    }

    protected processGetPatientSurvey(response: AxiosResponse): Promise<StringResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = StringResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringResponse>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param answers (optional) 
     * @return Success
     */
    updatePatientSurvey(id: number | undefined, answers: string | undefined, cancelToken?: CancelToken | undefined): Promise<Response> {
        let url_ = this.baseUrl + "/api/Patients/UpdatePatientSurvey?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        if (answers === null)
            throw new Error("The parameter 'answers' cannot be null.");
        else if (answers !== undefined)
            url_ += "answers=" + encodeURIComponent("" + answers) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processUpdatePatientSurvey(_response);
        });
    }

    protected processUpdatePatientSurvey(response: AxiosResponse): Promise<Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Response>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    completePatientSurvey(id: number | undefined, cancelToken?: CancelToken | undefined): Promise<Response> {
        let url_ = this.baseUrl + "/api/Patients/CompletePatientSurvey?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCompletePatientSurvey(_response);
        });
    }

    protected processCompletePatientSurvey(response: AxiosResponse): Promise<Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Response>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @return Success
     */
    getPersons(roleId: number | undefined, cancelToken?: CancelToken | undefined): Promise<PersonPagedResponse> {
        let url_ = this.baseUrl + "/api/Person/GetPersons?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPersons(_response);
        });
    }

    protected processGetPersons(response: AxiosResponse): Promise<PersonPagedResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = PersonPagedResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PersonPagedResponse>(<any>null);
    }

    /**
     * @param personId (optional) 
     * @return Success
     */
    getPerson(personId: number | undefined, cancelToken?: CancelToken | undefined): Promise<PersonResponse> {
        let url_ = this.baseUrl + "/api/Person/GetPerson?";
        if (personId === null)
            throw new Error("The parameter 'personId' cannot be null.");
        else if (personId !== undefined)
            url_ += "personId=" + encodeURIComponent("" + personId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPerson(_response);
        });
    }

    protected processGetPerson(response: AxiosResponse): Promise<PersonResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = PersonResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PersonResponse>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addPerson(body: Person | undefined, cancelToken?: CancelToken | undefined): Promise<Int32Response> {
        let url_ = this.baseUrl + "/api/Person/AddPerson";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAddPerson(_response);
        });
    }

    protected processAddPerson(response: AxiosResponse): Promise<Int32Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Int32Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Int32Response>(<any>null);
    }

    /**
     * @param personId (optional) 
     * @return Success
     */
    deletePerson(personId: number | undefined, cancelToken?: CancelToken | undefined): Promise<Response> {
        let url_ = this.baseUrl + "/api/Person/DeletePerson?";
        if (personId === null)
            throw new Error("The parameter 'personId' cannot be null.");
        else if (personId !== undefined)
            url_ += "personId=" + encodeURIComponent("" + personId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDeletePerson(_response);
        });
    }

    protected processDeletePerson(response: AxiosResponse): Promise<Response> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = Response.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Response>(<any>null);
    }

    /**
     * @param personId (optional) 
     * @return Success
     */
    getPersonAddresses(personId: number | undefined, cancelToken?: CancelToken | undefined): Promise<PersonAddressListResponse> {
        let url_ = this.baseUrl + "/api/Person/GetPersonAddresses?";
        if (personId === null)
            throw new Error("The parameter 'personId' cannot be null.");
        else if (personId !== undefined)
            url_ += "personId=" + encodeURIComponent("" + personId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPersonAddresses(_response);
        });
    }

    protected processGetPersonAddresses(response: AxiosResponse): Promise<PersonAddressListResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = PersonAddressListResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PersonAddressListResponse>(<any>null);
    }

    /**
     * @param personId (optional) 
     * @return Success
     */
    getPersonPhoneNumbers(personId: number | undefined, cancelToken?: CancelToken | undefined): Promise<PhoneNumberListResponse> {
        let url_ = this.baseUrl + "/api/Person/GetPersonPhoneNumbers?";
        if (personId === null)
            throw new Error("The parameter 'personId' cannot be null.");
        else if (personId !== undefined)
            url_ += "personId=" + encodeURIComponent("" + personId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPersonPhoneNumbers(_response);
        });
    }

    protected processGetPersonPhoneNumbers(response: AxiosResponse): Promise<PhoneNumberListResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = PhoneNumberListResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PhoneNumberListResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getPatientsConfiguration(cancelToken?: CancelToken | undefined): Promise<StringStringKeyValuePairListResponse> {
        let url_ = this.baseUrl + "/api/UIHelper/GetPatientsConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPatientsConfiguration(_response);
        });
    }

    protected processGetPatientsConfiguration(response: AxiosResponse): Promise<StringStringKeyValuePairListResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = StringStringKeyValuePairListResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringStringKeyValuePairListResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getDoctorsGridConfiguration(cancelToken?: CancelToken | undefined): Promise<StringStringKeyValuePairListResponse> {
        let url_ = this.baseUrl + "/api/UIHelper/GetDoctorsGridConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetDoctorsGridConfiguration(_response);
        });
    }

    protected processGetDoctorsGridConfiguration(response: AxiosResponse): Promise<StringStringKeyValuePairListResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = StringStringKeyValuePairListResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringStringKeyValuePairListResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getPatientGridConfiguration(cancelToken?: CancelToken | undefined): Promise<StringStringKeyValuePairListResponse> {
        let url_ = this.baseUrl + "/api/UIHelper/GetPatientGridConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPatientGridConfiguration(_response);
        });
    }

    protected processGetPatientGridConfiguration(response: AxiosResponse): Promise<StringStringKeyValuePairListResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = StringStringKeyValuePairListResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StringStringKeyValuePairListResponse>(<any>null);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    searchLocationByCityName(name: string | undefined, cancelToken?: CancelToken | undefined): Promise<CityListResponse> {
        let url_ = this.baseUrl + "/api/UIHelper/SearchLocationByCityName?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processSearchLocationByCityName(_response);
        });
    }

    protected processSearchLocationByCityName(response: AxiosResponse): Promise<CityListResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = CityListResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityListResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getGenders(cancelToken?: CancelToken | undefined): Promise<GenderArrayResponse> {
        let url_ = this.baseUrl + "/api/Values/GetGenders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetGenders(_response);
        });
    }

    protected processGetGenders(response: AxiosResponse): Promise<GenderArrayResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = GenderArrayResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GenderArrayResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getRegions(cancelToken?: CancelToken | undefined): Promise<RegionArrayResponse> {
        let url_ = this.baseUrl + "/api/Values/GetRegions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetRegions(_response);
        });
    }

    protected processGetRegions(response: AxiosResponse): Promise<RegionArrayResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = RegionArrayResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RegionArrayResponse>(<any>null);
    }

    /**
     * @param regionId (optional) 
     * @return Success
     */
    getCities(regionId: number | undefined, cancelToken?: CancelToken | undefined): Promise<CityArrayResponse> {
        let url_ = this.baseUrl + "/api/Values/GetCities?";
        if (regionId === null)
            throw new Error("The parameter 'regionId' cannot be null.");
        else if (regionId !== undefined)
            url_ += "regionId=" + encodeURIComponent("" + regionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetCities(_response);
        });
    }

    protected processGetCities(response: AxiosResponse): Promise<CityArrayResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = CityArrayResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CityArrayResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getAddressTypes(cancelToken?: CancelToken | undefined): Promise<AddressTypeListResponse> {
        let url_ = this.baseUrl + "/api/Values/GetAddressTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetAddressTypes(_response);
        });
    }

    protected processGetAddressTypes(response: AxiosResponse): Promise<AddressTypeListResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = AddressTypeListResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AddressTypeListResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getVisitTypes(cancelToken?: CancelToken | undefined): Promise<VisitTypeArrayResponse> {
        let url_ = this.baseUrl + "/api/Values/GetVisitTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetVisitTypes(_response);
        });
    }

    protected processGetVisitTypes(response: AxiosResponse): Promise<VisitTypeArrayResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = VisitTypeArrayResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<VisitTypeArrayResponse>(<any>null);
    }

    /**
     * @return Success
     */
    getPatientContactTypes(cancelToken?: CancelToken | undefined): Promise<ContactTypeArrayResponse> {
        let url_ = this.baseUrl + "/api/Values/GetPatientContactTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetPatientContactTypes(_response);
        });
    }

    protected processGetPatientContactTypes(response: AxiosResponse): Promise<ContactTypeArrayResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = ContactTypeArrayResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ContactTypeArrayResponse>(<any>null);
    }

    /**
     * @param cityId (optional) 
     * @return Success
     */
    getLocationByCityId(cityId: number | undefined, cancelToken?: CancelToken | undefined): Promise<LocationResponse> {
        let url_ = this.baseUrl + "/api/Values/GetLocationByCityId?";
        if (cityId === null)
            throw new Error("The parameter 'cityId' cannot be null.");
        else if (cityId !== undefined)
            url_ += "cityId=" + encodeURIComponent("" + cityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetLocationByCityId(_response);
        });
    }

    protected processGetLocationByCityId(response: AxiosResponse): Promise<LocationResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            result200 = LocationResponse.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LocationResponse>(<any>null);
    }

    /**
     * @return Success
     */
    weatherForecast(cancelToken?: CancelToken | undefined): Promise<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processWeatherForecast(_response);
        });
    }

    protected processWeatherForecast(response: AxiosResponse): Promise<WeatherForecast[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200 = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WeatherForecast[]>(<any>null);
    }
}

export class AddressType implements IAddressType {
    id!: number;
    name!: string | null;
    active!: boolean;

    constructor(data?: IAddressType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
        }
    }

    static fromJS(data: any): AddressType {
        data = typeof data === 'object' ? data : {};
        let result = new AddressType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        return data;
    }
}

export interface IAddressType {
    id: number;
    name: string | null;
    active: boolean;
}

export class AddressTypeListResponse implements IAddressTypeListResponse {
    status!: string | null;
    message!: string | null;
    data!: AddressType[] | null;

    constructor(data?: IAddressTypeListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(AddressType.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): AddressTypeListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AddressTypeListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAddressTypeListResponse {
    status: string | null;
    message: string | null;
    data: AddressType[] | null;
}

export class AuditInfo implements IAuditInfo {
    createdDate!: Date;
    createdBy!: string | null;
    lastUpdateDate!: Date;
    lastUpdatedBy!: string | null;
    deletedDate!: Date;
    deletedBy!: string | null;
    deleted!: boolean;

    constructor(data?: IAuditInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>null;
            this.createdBy = _data["createdBy"] !== undefined ? _data["createdBy"] : <any>null;
            this.lastUpdateDate = _data["lastUpdateDate"] ? new Date(_data["lastUpdateDate"].toString()) : <any>null;
            this.lastUpdatedBy = _data["lastUpdatedBy"] !== undefined ? _data["lastUpdatedBy"] : <any>null;
            this.deletedDate = _data["deletedDate"] ? new Date(_data["deletedDate"].toString()) : <any>null;
            this.deletedBy = _data["deletedBy"] !== undefined ? _data["deletedBy"] : <any>null;
            this.deleted = _data["deleted"] !== undefined ? _data["deleted"] : <any>null;
        }
    }

    static fromJS(data: any): AuditInfo {
        data = typeof data === 'object' ? data : {};
        let result = new AuditInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>null;
        data["createdBy"] = this.createdBy !== undefined ? this.createdBy : <any>null;
        data["lastUpdateDate"] = this.lastUpdateDate ? this.lastUpdateDate.toISOString() : <any>null;
        data["lastUpdatedBy"] = this.lastUpdatedBy !== undefined ? this.lastUpdatedBy : <any>null;
        data["deletedDate"] = this.deletedDate ? this.deletedDate.toISOString() : <any>null;
        data["deletedBy"] = this.deletedBy !== undefined ? this.deletedBy : <any>null;
        data["deleted"] = this.deleted !== undefined ? this.deleted : <any>null;
        return data;
    }
}

export interface IAuditInfo {
    createdDate: Date;
    createdBy: string | null;
    lastUpdateDate: Date;
    lastUpdatedBy: string | null;
    deletedDate: Date;
    deletedBy: string | null;
    deleted: boolean;
}

export class City implements ICity {
    id!: number;
    name!: string | null;
    active!: boolean;
    regionId!: number;

    constructor(data?: ICity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.regionId = _data["regionId"] !== undefined ? _data["regionId"] : <any>null;
        }
    }

    static fromJS(data: any): City {
        data = typeof data === 'object' ? data : {};
        let result = new City();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["regionId"] = this.regionId !== undefined ? this.regionId : <any>null;
        return data;
    }
}

export interface ICity {
    id: number;
    name: string | null;
    active: boolean;
    regionId: number;
}

export class CityArrayResponse implements ICityArrayResponse {
    status!: string | null;
    message!: string | null;
    data!: City[] | null;

    constructor(data?: ICityArrayResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(City.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): CityArrayResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CityArrayResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICityArrayResponse {
    status: string | null;
    message: string | null;
    data: City[] | null;
}

export class CityListResponse implements ICityListResponse {
    status!: string | null;
    message!: string | null;
    data!: City[] | null;

    constructor(data?: ICityListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(City.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): CityListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new CityListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICityListResponse {
    status: string | null;
    message: string | null;
    data: City[] | null;
}

export class Contact implements IContact {
    id!: number;
    firstName!: string | null;
    lastName!: string | null;
    emailAddress!: string | null;
    location!: Location;
    middleName!: string | null;
    address1!: string | null;
    address2!: string | null;
    title!: string | null;
    suffix!: string | null;
    cellPhone!: string | null;
    homePhone!: string | null;
    gender!: Gender;
    active!: boolean;
    patientId!: number;
    contactType!: ContactType;
    contactTypeId!: number;
    otherContact!: string | null;

    constructor(data?: IContact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.emailAddress = _data["emailAddress"] !== undefined ? _data["emailAddress"] : <any>null;
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>null;
            this.middleName = _data["middleName"] !== undefined ? _data["middleName"] : <any>null;
            this.address1 = _data["address1"] !== undefined ? _data["address1"] : <any>null;
            this.address2 = _data["address2"] !== undefined ? _data["address2"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.suffix = _data["suffix"] !== undefined ? _data["suffix"] : <any>null;
            this.cellPhone = _data["cellPhone"] !== undefined ? _data["cellPhone"] : <any>null;
            this.homePhone = _data["homePhone"] !== undefined ? _data["homePhone"] : <any>null;
            this.gender = _data["gender"] ? Gender.fromJS(_data["gender"]) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.patientId = _data["patientId"] !== undefined ? _data["patientId"] : <any>null;
            this.contactType = _data["contactType"] ? ContactType.fromJS(_data["contactType"]) : <any>null;
            this.contactTypeId = _data["contactTypeId"] !== undefined ? _data["contactTypeId"] : <any>null;
            this.otherContact = _data["otherContact"] !== undefined ? _data["otherContact"] : <any>null;
        }
    }

    static fromJS(data: any): Contact {
        data = typeof data === 'object' ? data : {};
        let result = new Contact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["emailAddress"] = this.emailAddress !== undefined ? this.emailAddress : <any>null;
        data["location"] = this.location ? this.location.toJSON() : <any>null;
        data["middleName"] = this.middleName !== undefined ? this.middleName : <any>null;
        data["address1"] = this.address1 !== undefined ? this.address1 : <any>null;
        data["address2"] = this.address2 !== undefined ? this.address2 : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["suffix"] = this.suffix !== undefined ? this.suffix : <any>null;
        data["cellPhone"] = this.cellPhone !== undefined ? this.cellPhone : <any>null;
        data["homePhone"] = this.homePhone !== undefined ? this.homePhone : <any>null;
        data["gender"] = this.gender ? this.gender.toJSON() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["patientId"] = this.patientId !== undefined ? this.patientId : <any>null;
        data["contactType"] = this.contactType ? this.contactType.toJSON() : <any>null;
        data["contactTypeId"] = this.contactTypeId !== undefined ? this.contactTypeId : <any>null;
        data["otherContact"] = this.otherContact !== undefined ? this.otherContact : <any>null;
        return data;
    }
}

export interface IContact {
    id: number;
    firstName: string | null;
    lastName: string | null;
    emailAddress: string | null;
    location: Location;
    middleName: string | null;
    address1: string | null;
    address2: string | null;
    title: string | null;
    suffix: string | null;
    cellPhone: string | null;
    homePhone: string | null;
    gender: Gender;
    active: boolean;
    patientId: number;
    contactType: ContactType;
    contactTypeId: number;
    otherContact: string | null;
}

export class ContactPagedResponse implements IContactPagedResponse {
    status!: string | null;
    message!: string | null;
    currentPage!: number;
    pageCount!: number;
    pageSize!: number;
    rowCount!: number;
    data!: Contact[] | null;

    constructor(data?: IContactPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.rowCount = _data["rowCount"] !== undefined ? _data["rowCount"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Contact.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): ContactPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContactPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["rowCount"] = this.rowCount !== undefined ? this.rowCount : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContactPagedResponse {
    status: string | null;
    message: string | null;
    currentPage: number;
    pageCount: number;
    pageSize: number;
    rowCount: number;
    data: Contact[] | null;
}

export class ContactResponse implements IContactResponse {
    status!: string | null;
    message!: string | null;
    data!: Contact;

    constructor(data?: IContactResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.data = _data["data"] ? Contact.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): ContactResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContactResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data;
    }
}

export interface IContactResponse {
    status: string | null;
    message: string | null;
    data: Contact;
}

export class ContactType implements IContactType {
    id!: number;
    name!: string | null;
    active!: boolean;

    constructor(data?: IContactType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
        }
    }

    static fromJS(data: any): ContactType {
        data = typeof data === 'object' ? data : {};
        let result = new ContactType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        return data;
    }
}

export interface IContactType {
    id: number;
    name: string | null;
    active: boolean;
}

export class ContactTypeArrayResponse implements IContactTypeArrayResponse {
    status!: string | null;
    message!: string | null;
    data!: ContactType[] | null;

    constructor(data?: IContactTypeArrayResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(ContactType.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): ContactTypeArrayResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ContactTypeArrayResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IContactTypeArrayResponse {
    status: string | null;
    message: string | null;
    data: ContactType[] | null;
}

export class Country implements ICountry {
    id!: number;
    name!: string | null;
    active!: boolean;

    constructor(data?: ICountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
        }
    }

    static fromJS(data: any): Country {
        data = typeof data === 'object' ? data : {};
        let result = new Country();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        return data;
    }
}

export interface ICountry {
    id: number;
    name: string | null;
    active: boolean;
}

export class Gender implements IGender {
    id!: number;
    name!: string | null;
    active!: boolean;

    constructor(data?: IGender) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
        }
    }

    static fromJS(data: any): Gender {
        data = typeof data === 'object' ? data : {};
        let result = new Gender();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        return data;
    }
}

export interface IGender {
    id: number;
    name: string | null;
    active: boolean;
}

export class GenderArrayResponse implements IGenderArrayResponse {
    status!: string | null;
    message!: string | null;
    data!: Gender[] | null;

    constructor(data?: IGenderArrayResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Gender.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): GenderArrayResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GenderArrayResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGenderArrayResponse {
    status: string | null;
    message: string | null;
    data: Gender[] | null;
}

export class Int32Response implements IInt32Response {
    status!: string | null;
    message!: string | null;
    data!: number;

    constructor(data?: IInt32Response) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.data = _data["data"] !== undefined ? _data["data"] : <any>null;
        }
    }

    static fromJS(data: any): Int32Response {
        data = typeof data === 'object' ? data : {};
        let result = new Int32Response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["data"] = this.data !== undefined ? this.data : <any>null;
        return data;
    }
}

export interface IInt32Response {
    status: string | null;
    message: string | null;
    data: number;
}

export class ListSearch implements IListSearch {
    criteria!: string | null;
    paging!: Paging;
    sort!: string | null;

    constructor(data?: IListSearch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.criteria = _data["criteria"] !== undefined ? _data["criteria"] : <any>null;
            this.paging = _data["paging"] ? Paging.fromJS(_data["paging"]) : <any>null;
            this.sort = _data["sort"] !== undefined ? _data["sort"] : <any>null;
        }
    }

    static fromJS(data: any): ListSearch {
        data = typeof data === 'object' ? data : {};
        let result = new ListSearch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["criteria"] = this.criteria !== undefined ? this.criteria : <any>null;
        data["paging"] = this.paging ? this.paging.toJSON() : <any>null;
        data["sort"] = this.sort !== undefined ? this.sort : <any>null;
        return data;
    }
}

export interface IListSearch {
    criteria: string | null;
    paging: Paging;
    sort: string | null;
}

export class Location implements ILocation {
    city!: City;
    region!: Region;
    country!: Country;

    constructor(data?: ILocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.city = _data["city"] ? City.fromJS(_data["city"]) : <any>null;
            this.region = _data["region"] ? Region.fromJS(_data["region"]) : <any>null;
            this.country = _data["country"] ? Country.fromJS(_data["country"]) : <any>null;
        }
    }

    static fromJS(data: any): Location {
        data = typeof data === 'object' ? data : {};
        let result = new Location();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["city"] = this.city ? this.city.toJSON() : <any>null;
        data["region"] = this.region ? this.region.toJSON() : <any>null;
        data["country"] = this.country ? this.country.toJSON() : <any>null;
        return data;
    }
}

export interface ILocation {
    city: City;
    region: Region;
    country: Country;
}

export class LocationResponse implements ILocationResponse {
    status!: string | null;
    message!: string | null;
    data!: Location;

    constructor(data?: ILocationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.data = _data["data"] ? Location.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): LocationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LocationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data;
    }
}

export interface ILocationResponse {
    status: string | null;
    message: string | null;
    data: Location;
}

export class Paging implements IPaging {
    pageSize!: number;
    pageIndex!: number;

    constructor(data?: IPaging) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.pageIndex = _data["pageIndex"] !== undefined ? _data["pageIndex"] : <any>null;
        }
    }

    static fromJS(data: any): Paging {
        data = typeof data === 'object' ? data : {};
        let result = new Paging();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["pageIndex"] = this.pageIndex !== undefined ? this.pageIndex : <any>null;
        return data;
    }
}

export interface IPaging {
    pageSize: number;
    pageIndex: number;
}

export class Patient implements IPatient {
    id!: number;
    firstName!: string | null;
    lastName!: string | null;
    emailAddress!: string | null;
    location!: Location;
    middleName!: string | null;
    address1!: string | null;
    address2!: string | null;
    title!: string | null;
    suffix!: string | null;
    cellPhone!: string | null;
    homePhone!: string | null;
    active!: boolean;
    birthDate!: Date;
    gender!: Gender;

    constructor(data?: IPatient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.emailAddress = _data["emailAddress"] !== undefined ? _data["emailAddress"] : <any>null;
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>null;
            this.middleName = _data["middleName"] !== undefined ? _data["middleName"] : <any>null;
            this.address1 = _data["address1"] !== undefined ? _data["address1"] : <any>null;
            this.address2 = _data["address2"] !== undefined ? _data["address2"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.suffix = _data["suffix"] !== undefined ? _data["suffix"] : <any>null;
            this.cellPhone = _data["cellPhone"] !== undefined ? _data["cellPhone"] : <any>null;
            this.homePhone = _data["homePhone"] !== undefined ? _data["homePhone"] : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>null;
            this.gender = _data["gender"] ? Gender.fromJS(_data["gender"]) : <any>null;
        }
    }

    static fromJS(data: any): Patient {
        data = typeof data === 'object' ? data : {};
        let result = new Patient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["emailAddress"] = this.emailAddress !== undefined ? this.emailAddress : <any>null;
        data["location"] = this.location ? this.location.toJSON() : <any>null;
        data["middleName"] = this.middleName !== undefined ? this.middleName : <any>null;
        data["address1"] = this.address1 !== undefined ? this.address1 : <any>null;
        data["address2"] = this.address2 !== undefined ? this.address2 : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["suffix"] = this.suffix !== undefined ? this.suffix : <any>null;
        data["cellPhone"] = this.cellPhone !== undefined ? this.cellPhone : <any>null;
        data["homePhone"] = this.homePhone !== undefined ? this.homePhone : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>null;
        data["gender"] = this.gender ? this.gender.toJSON() : <any>null;
        return data;
    }
}

export interface IPatient {
    id: number;
    firstName: string | null;
    lastName: string | null;
    emailAddress: string | null;
    location: Location;
    middleName: string | null;
    address1: string | null;
    address2: string | null;
    title: string | null;
    suffix: string | null;
    cellPhone: string | null;
    homePhone: string | null;
    active: boolean;
    birthDate: Date;
    gender: Gender;
}

export class PatientPagedResponse implements IPatientPagedResponse {
    status!: string | null;
    message!: string | null;
    currentPage!: number;
    pageCount!: number;
    pageSize!: number;
    rowCount!: number;
    data!: Patient[] | null;

    constructor(data?: IPatientPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.rowCount = _data["rowCount"] !== undefined ? _data["rowCount"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Patient.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): PatientPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PatientPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["rowCount"] = this.rowCount !== undefined ? this.rowCount : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPatientPagedResponse {
    status: string | null;
    message: string | null;
    currentPage: number;
    pageCount: number;
    pageSize: number;
    rowCount: number;
    data: Patient[] | null;
}

export class PatientResponse implements IPatientResponse {
    status!: string | null;
    message!: string | null;
    data!: Patient;

    constructor(data?: IPatientResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.data = _data["data"] ? Patient.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): PatientResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PatientResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data;
    }
}

export interface IPatientResponse {
    status: string | null;
    message: string | null;
    data: Patient;
}

export class PatientSurvey implements IPatientSurvey {
    patientSurveyId!: number;
    surveyName!: string | null;
    dateAssigned!: Date;
    completedDate!: Date | null;
    completedBy!: string | null;
    status!: PatientSurveyStatus;

    constructor(data?: IPatientSurvey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.patientSurveyId = _data["patientSurveyId"] !== undefined ? _data["patientSurveyId"] : <any>null;
            this.surveyName = _data["surveyName"] !== undefined ? _data["surveyName"] : <any>null;
            this.dateAssigned = _data["dateAssigned"] ? new Date(_data["dateAssigned"].toString()) : <any>null;
            this.completedDate = _data["completedDate"] ? new Date(_data["completedDate"].toString()) : <any>null;
            this.completedBy = _data["completedBy"] !== undefined ? _data["completedBy"] : <any>null;
            this.status = _data["status"] ? PatientSurveyStatus.fromJS(_data["status"]) : <any>null;
        }
    }

    static fromJS(data: any): PatientSurvey {
        data = typeof data === 'object' ? data : {};
        let result = new PatientSurvey();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["patientSurveyId"] = this.patientSurveyId !== undefined ? this.patientSurveyId : <any>null;
        data["surveyName"] = this.surveyName !== undefined ? this.surveyName : <any>null;
        data["dateAssigned"] = this.dateAssigned ? this.dateAssigned.toISOString() : <any>null;
        data["completedDate"] = this.completedDate ? this.completedDate.toISOString() : <any>null;
        data["completedBy"] = this.completedBy !== undefined ? this.completedBy : <any>null;
        data["status"] = this.status ? this.status.toJSON() : <any>null;
        return data;
    }
}

export interface IPatientSurvey {
    patientSurveyId: number;
    surveyName: string | null;
    dateAssigned: Date;
    completedDate: Date | null;
    completedBy: string | null;
    status: PatientSurveyStatus;
}

export class PatientSurveyPagedResponse implements IPatientSurveyPagedResponse {
    status!: string | null;
    message!: string | null;
    currentPage!: number;
    pageCount!: number;
    pageSize!: number;
    rowCount!: number;
    data!: PatientSurvey[] | null;

    constructor(data?: IPatientSurveyPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.rowCount = _data["rowCount"] !== undefined ? _data["rowCount"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PatientSurvey.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): PatientSurveyPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PatientSurveyPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["rowCount"] = this.rowCount !== undefined ? this.rowCount : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPatientSurveyPagedResponse {
    status: string | null;
    message: string | null;
    currentPage: number;
    pageCount: number;
    pageSize: number;
    rowCount: number;
    data: PatientSurvey[] | null;
}

export class PatientSurveyStatus implements IPatientSurveyStatus {
    id!: number;
    name!: string | null;
    active!: boolean;

    constructor(data?: IPatientSurveyStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
        }
    }

    static fromJS(data: any): PatientSurveyStatus {
        data = typeof data === 'object' ? data : {};
        let result = new PatientSurveyStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        return data;
    }
}

export interface IPatientSurveyStatus {
    id: number;
    name: string | null;
    active: boolean;
}

export class Person implements IPerson {
    id!: number;
    firstName!: string | null;
    lastName!: string | null;
    emailAddress!: string | null;
    location!: Location;
    middleName!: string | null;
    address1!: string | null;
    address2!: string | null;
    title!: string | null;
    suffix!: string | null;
    cellPhone!: string | null;
    homePhone!: string | null;
    gender!: Gender;
    active!: boolean;
    birthDate!: Date;
    role!: PersonRole;
    auditInfo!: AuditInfo;
    roles!: PersonRole[] | null;
    addresses!: PersonAddress[] | null;

    constructor(data?: IPerson) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.firstName = _data["firstName"] !== undefined ? _data["firstName"] : <any>null;
            this.lastName = _data["lastName"] !== undefined ? _data["lastName"] : <any>null;
            this.emailAddress = _data["emailAddress"] !== undefined ? _data["emailAddress"] : <any>null;
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>null;
            this.middleName = _data["middleName"] !== undefined ? _data["middleName"] : <any>null;
            this.address1 = _data["address1"] !== undefined ? _data["address1"] : <any>null;
            this.address2 = _data["address2"] !== undefined ? _data["address2"] : <any>null;
            this.title = _data["title"] !== undefined ? _data["title"] : <any>null;
            this.suffix = _data["suffix"] !== undefined ? _data["suffix"] : <any>null;
            this.cellPhone = _data["cellPhone"] !== undefined ? _data["cellPhone"] : <any>null;
            this.homePhone = _data["homePhone"] !== undefined ? _data["homePhone"] : <any>null;
            this.gender = _data["gender"] ? Gender.fromJS(_data["gender"]) : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>null;
            this.role = _data["role"] ? PersonRole.fromJS(_data["role"]) : <any>null;
            this.auditInfo = _data["auditInfo"] ? AuditInfo.fromJS(_data["auditInfo"]) : <any>null;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(PersonRole.fromJS(item));
            }
            else {
                this.roles = <any>null;
            }
            if (Array.isArray(_data["addresses"])) {
                this.addresses = [] as any;
                for (let item of _data["addresses"])
                    this.addresses!.push(PersonAddress.fromJS(item));
            }
            else {
                this.addresses = <any>null;
            }
        }
    }

    static fromJS(data: any): Person {
        data = typeof data === 'object' ? data : {};
        let result = new Person();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["emailAddress"] = this.emailAddress !== undefined ? this.emailAddress : <any>null;
        data["location"] = this.location ? this.location.toJSON() : <any>null;
        data["middleName"] = this.middleName !== undefined ? this.middleName : <any>null;
        data["address1"] = this.address1 !== undefined ? this.address1 : <any>null;
        data["address2"] = this.address2 !== undefined ? this.address2 : <any>null;
        data["title"] = this.title !== undefined ? this.title : <any>null;
        data["suffix"] = this.suffix !== undefined ? this.suffix : <any>null;
        data["cellPhone"] = this.cellPhone !== undefined ? this.cellPhone : <any>null;
        data["homePhone"] = this.homePhone !== undefined ? this.homePhone : <any>null;
        data["gender"] = this.gender ? this.gender.toJSON() : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>null;
        data["role"] = this.role ? this.role.toJSON() : <any>null;
        data["auditInfo"] = this.auditInfo ? this.auditInfo.toJSON() : <any>null;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.addresses)) {
            data["addresses"] = [];
            for (let item of this.addresses)
                data["addresses"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPerson {
    id: number;
    firstName: string | null;
    lastName: string | null;
    emailAddress: string | null;
    location: Location;
    middleName: string | null;
    address1: string | null;
    address2: string | null;
    title: string | null;
    suffix: string | null;
    cellPhone: string | null;
    homePhone: string | null;
    gender: Gender;
    active: boolean;
    birthDate: Date;
    role: PersonRole;
    auditInfo: AuditInfo;
    roles: PersonRole[] | null;
    addresses: PersonAddress[] | null;
}

export class PersonAddress implements IPersonAddress {
    id!: number;
    name!: string | null;
    active!: boolean;
    location!: Location;
    address1!: string | null;
    address2!: string | null;
    type!: AddressType;
    personId!: number;
    auditInfo!: AuditInfo;
    phoneNumber!: string | null;

    constructor(data?: IPersonAddress) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.location = _data["location"] ? Location.fromJS(_data["location"]) : <any>null;
            this.address1 = _data["address1"] !== undefined ? _data["address1"] : <any>null;
            this.address2 = _data["address2"] !== undefined ? _data["address2"] : <any>null;
            this.type = _data["type"] ? AddressType.fromJS(_data["type"]) : <any>null;
            this.personId = _data["personId"] !== undefined ? _data["personId"] : <any>null;
            this.auditInfo = _data["auditInfo"] ? AuditInfo.fromJS(_data["auditInfo"]) : <any>null;
            this.phoneNumber = _data["phoneNumber"] !== undefined ? _data["phoneNumber"] : <any>null;
        }
    }

    static fromJS(data: any): PersonAddress {
        data = typeof data === 'object' ? data : {};
        let result = new PersonAddress();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["location"] = this.location ? this.location.toJSON() : <any>null;
        data["address1"] = this.address1 !== undefined ? this.address1 : <any>null;
        data["address2"] = this.address2 !== undefined ? this.address2 : <any>null;
        data["type"] = this.type ? this.type.toJSON() : <any>null;
        data["personId"] = this.personId !== undefined ? this.personId : <any>null;
        data["auditInfo"] = this.auditInfo ? this.auditInfo.toJSON() : <any>null;
        data["phoneNumber"] = this.phoneNumber !== undefined ? this.phoneNumber : <any>null;
        return data;
    }
}

export interface IPersonAddress {
    id: number;
    name: string | null;
    active: boolean;
    location: Location;
    address1: string | null;
    address2: string | null;
    type: AddressType;
    personId: number;
    auditInfo: AuditInfo;
    phoneNumber: string | null;
}

export class PersonAddressListResponse implements IPersonAddressListResponse {
    status!: string | null;
    message!: string | null;
    data!: PersonAddress[] | null;

    constructor(data?: IPersonAddressListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PersonAddress.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): PersonAddressListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PersonAddressListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPersonAddressListResponse {
    status: string | null;
    message: string | null;
    data: PersonAddress[] | null;
}

export class PersonAddressResponse implements IPersonAddressResponse {
    status!: string | null;
    message!: string | null;
    data!: PersonAddress;

    constructor(data?: IPersonAddressResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.data = _data["data"] ? PersonAddress.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): PersonAddressResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PersonAddressResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data;
    }
}

export interface IPersonAddressResponse {
    status: string | null;
    message: string | null;
    data: PersonAddress;
}

export class PersonPagedResponse implements IPersonPagedResponse {
    status!: string | null;
    message!: string | null;
    currentPage!: number;
    pageCount!: number;
    pageSize!: number;
    rowCount!: number;
    data!: Person[] | null;

    constructor(data?: IPersonPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.rowCount = _data["rowCount"] !== undefined ? _data["rowCount"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Person.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): PersonPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PersonPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["rowCount"] = this.rowCount !== undefined ? this.rowCount : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPersonPagedResponse {
    status: string | null;
    message: string | null;
    currentPage: number;
    pageCount: number;
    pageSize: number;
    rowCount: number;
    data: Person[] | null;
}

export class PersonResponse implements IPersonResponse {
    status!: string | null;
    message!: string | null;
    data!: Person;

    constructor(data?: IPersonResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.data = _data["data"] ? Person.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): PersonResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PersonResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data;
    }
}

export interface IPersonResponse {
    status: string | null;
    message: string | null;
    data: Person;
}

export class PersonRole implements IPersonRole {
    id!: number;
    name!: string | null;
    active!: boolean;

    constructor(data?: IPersonRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
        }
    }

    static fromJS(data: any): PersonRole {
        data = typeof data === 'object' ? data : {};
        let result = new PersonRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        return data;
    }
}

export interface IPersonRole {
    id: number;
    name: string | null;
    active: boolean;
}

export class PhoneNumber implements IPhoneNumber {
    id!: number;
    active!: boolean;
    type!: PhoneNumberType;
    phoneNumberValue!: string | null;
    auditInfo!: AuditInfo;

    constructor(data?: IPhoneNumber) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.type = _data["type"] ? PhoneNumberType.fromJS(_data["type"]) : <any>null;
            this.phoneNumberValue = _data["phoneNumberValue"] !== undefined ? _data["phoneNumberValue"] : <any>null;
            this.auditInfo = _data["auditInfo"] ? AuditInfo.fromJS(_data["auditInfo"]) : <any>null;
        }
    }

    static fromJS(data: any): PhoneNumber {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneNumber();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["type"] = this.type ? this.type.toJSON() : <any>null;
        data["phoneNumberValue"] = this.phoneNumberValue !== undefined ? this.phoneNumberValue : <any>null;
        data["auditInfo"] = this.auditInfo ? this.auditInfo.toJSON() : <any>null;
        return data;
    }
}

export interface IPhoneNumber {
    id: number;
    active: boolean;
    type: PhoneNumberType;
    phoneNumberValue: string | null;
    auditInfo: AuditInfo;
}

export class PhoneNumberListResponse implements IPhoneNumberListResponse {
    status!: string | null;
    message!: string | null;
    data!: PhoneNumber[] | null;

    constructor(data?: IPhoneNumberListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PhoneNumber.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): PhoneNumberListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneNumberListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPhoneNumberListResponse {
    status: string | null;
    message: string | null;
    data: PhoneNumber[] | null;
}

export class PhoneNumberType implements IPhoneNumberType {
    id!: number;
    name!: string | null;
    active!: boolean;

    constructor(data?: IPhoneNumberType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
        }
    }

    static fromJS(data: any): PhoneNumberType {
        data = typeof data === 'object' ? data : {};
        let result = new PhoneNumberType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        return data;
    }
}

export interface IPhoneNumberType {
    id: number;
    name: string | null;
    active: boolean;
}

export class Region implements IRegion {
    id!: number;
    name!: string | null;
    active!: boolean;
    countryId!: number;

    constructor(data?: IRegion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
            this.countryId = _data["countryId"] !== undefined ? _data["countryId"] : <any>null;
        }
    }

    static fromJS(data: any): Region {
        data = typeof data === 'object' ? data : {};
        let result = new Region();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        data["countryId"] = this.countryId !== undefined ? this.countryId : <any>null;
        return data;
    }
}

export interface IRegion {
    id: number;
    name: string | null;
    active: boolean;
    countryId: number;
}

export class RegionArrayResponse implements IRegionArrayResponse {
    status!: string | null;
    message!: string | null;
    data!: Region[] | null;

    constructor(data?: IRegionArrayResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Region.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): RegionArrayResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RegionArrayResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IRegionArrayResponse {
    status: string | null;
    message: string | null;
    data: Region[] | null;
}

export class Response implements IResponse {
    status!: string | null;
    message!: string | null;

    constructor(data?: IResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
        }
    }

    static fromJS(data: any): Response {
        data = typeof data === 'object' ? data : {};
        let result = new Response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        return data;
    }
}

export interface IResponse {
    status: string | null;
    message: string | null;
}

export class StringResponse implements IStringResponse {
    status!: string | null;
    message!: string | null;
    data!: string | null;

    constructor(data?: IStringResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.data = _data["data"] !== undefined ? _data["data"] : <any>null;
        }
    }

    static fromJS(data: any): StringResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["data"] = this.data !== undefined ? this.data : <any>null;
        return data;
    }
}

export interface IStringResponse {
    status: string | null;
    message: string | null;
    data: string | null;
}

export class StringStringKeyValuePair implements IStringStringKeyValuePair {
    readonly key!: string | null;
    readonly value!: string | null;

    constructor(data?: IStringStringKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).key = _data["key"] !== undefined ? _data["key"] : <any>null;
            (<any>this).value = _data["value"] !== undefined ? _data["value"] : <any>null;
        }
    }

    static fromJS(data: any): StringStringKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key !== undefined ? this.key : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IStringStringKeyValuePair {
    key: string | null;
    value: string | null;
}

export class StringStringKeyValuePairListResponse implements IStringStringKeyValuePairListResponse {
    status!: string | null;
    message!: string | null;
    data!: StringStringKeyValuePair[] | null;

    constructor(data?: IStringStringKeyValuePairListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(StringStringKeyValuePair.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): StringStringKeyValuePairListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new StringStringKeyValuePairListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IStringStringKeyValuePairListResponse {
    status: string | null;
    message: string | null;
    data: StringStringKeyValuePair[] | null;
}

export class Visit implements IVisit {
    id!: number;
    name!: string | null;
    visitTypeId!: number;
    visitDate!: Date;
    foodMedicationAllergies!: string | null;
    typeOfAllergies!: string | null;
    smokes!: boolean;
    smokesPacksPerDay!: number;
    drinksAlcohol!: boolean;
    alcoholPerDay!: number;
    medications!: string | null;
    lastFluShotDate!: Date | null;
    lastPneumoShotDate!: Date | null;
    additionalInfo!: string | null;
    visitType!: VisitType;
    patientId!: number;

    constructor(data?: IVisit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.visitTypeId = _data["visitTypeId"] !== undefined ? _data["visitTypeId"] : <any>null;
            this.visitDate = _data["visitDate"] ? new Date(_data["visitDate"].toString()) : <any>null;
            this.foodMedicationAllergies = _data["foodMedicationAllergies"] !== undefined ? _data["foodMedicationAllergies"] : <any>null;
            this.typeOfAllergies = _data["typeOfAllergies"] !== undefined ? _data["typeOfAllergies"] : <any>null;
            this.smokes = _data["smokes"] !== undefined ? _data["smokes"] : <any>null;
            this.smokesPacksPerDay = _data["smokesPacksPerDay"] !== undefined ? _data["smokesPacksPerDay"] : <any>null;
            this.drinksAlcohol = _data["drinksAlcohol"] !== undefined ? _data["drinksAlcohol"] : <any>null;
            this.alcoholPerDay = _data["alcoholPerDay"] !== undefined ? _data["alcoholPerDay"] : <any>null;
            this.medications = _data["medications"] !== undefined ? _data["medications"] : <any>null;
            this.lastFluShotDate = _data["lastFluShotDate"] ? new Date(_data["lastFluShotDate"].toString()) : <any>null;
            this.lastPneumoShotDate = _data["lastPneumoShotDate"] ? new Date(_data["lastPneumoShotDate"].toString()) : <any>null;
            this.additionalInfo = _data["additionalInfo"] !== undefined ? _data["additionalInfo"] : <any>null;
            this.visitType = _data["visitType"] ? VisitType.fromJS(_data["visitType"]) : <any>null;
            this.patientId = _data["patientId"] !== undefined ? _data["patientId"] : <any>null;
        }
    }

    static fromJS(data: any): Visit {
        data = typeof data === 'object' ? data : {};
        let result = new Visit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["visitTypeId"] = this.visitTypeId !== undefined ? this.visitTypeId : <any>null;
        data["visitDate"] = this.visitDate ? this.visitDate.toISOString() : <any>null;
        data["foodMedicationAllergies"] = this.foodMedicationAllergies !== undefined ? this.foodMedicationAllergies : <any>null;
        data["typeOfAllergies"] = this.typeOfAllergies !== undefined ? this.typeOfAllergies : <any>null;
        data["smokes"] = this.smokes !== undefined ? this.smokes : <any>null;
        data["smokesPacksPerDay"] = this.smokesPacksPerDay !== undefined ? this.smokesPacksPerDay : <any>null;
        data["drinksAlcohol"] = this.drinksAlcohol !== undefined ? this.drinksAlcohol : <any>null;
        data["alcoholPerDay"] = this.alcoholPerDay !== undefined ? this.alcoholPerDay : <any>null;
        data["medications"] = this.medications !== undefined ? this.medications : <any>null;
        data["lastFluShotDate"] = this.lastFluShotDate ? this.lastFluShotDate.toISOString() : <any>null;
        data["lastPneumoShotDate"] = this.lastPneumoShotDate ? this.lastPneumoShotDate.toISOString() : <any>null;
        data["additionalInfo"] = this.additionalInfo !== undefined ? this.additionalInfo : <any>null;
        data["visitType"] = this.visitType ? this.visitType.toJSON() : <any>null;
        data["patientId"] = this.patientId !== undefined ? this.patientId : <any>null;
        return data;
    }
}

export interface IVisit {
    id: number;
    name: string | null;
    visitTypeId: number;
    visitDate: Date;
    foodMedicationAllergies: string | null;
    typeOfAllergies: string | null;
    smokes: boolean;
    smokesPacksPerDay: number;
    drinksAlcohol: boolean;
    alcoholPerDay: number;
    medications: string | null;
    lastFluShotDate: Date | null;
    lastPneumoShotDate: Date | null;
    additionalInfo: string | null;
    visitType: VisitType;
    patientId: number;
}

export class VisitPagedResponse implements IVisitPagedResponse {
    status!: string | null;
    message!: string | null;
    currentPage!: number;
    pageCount!: number;
    pageSize!: number;
    rowCount!: number;
    data!: Visit[] | null;

    constructor(data?: IVisitPagedResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.currentPage = _data["currentPage"] !== undefined ? _data["currentPage"] : <any>null;
            this.pageCount = _data["pageCount"] !== undefined ? _data["pageCount"] : <any>null;
            this.pageSize = _data["pageSize"] !== undefined ? _data["pageSize"] : <any>null;
            this.rowCount = _data["rowCount"] !== undefined ? _data["rowCount"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Visit.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): VisitPagedResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VisitPagedResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["currentPage"] = this.currentPage !== undefined ? this.currentPage : <any>null;
        data["pageCount"] = this.pageCount !== undefined ? this.pageCount : <any>null;
        data["pageSize"] = this.pageSize !== undefined ? this.pageSize : <any>null;
        data["rowCount"] = this.rowCount !== undefined ? this.rowCount : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVisitPagedResponse {
    status: string | null;
    message: string | null;
    currentPage: number;
    pageCount: number;
    pageSize: number;
    rowCount: number;
    data: Visit[] | null;
}

export class VisitResponse implements IVisitResponse {
    status!: string | null;
    message!: string | null;
    data!: Visit;

    constructor(data?: IVisitResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            this.data = _data["data"] ? Visit.fromJS(_data["data"]) : <any>null;
        }
    }

    static fromJS(data: any): VisitResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VisitResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        data["data"] = this.data ? this.data.toJSON() : <any>null;
        return data;
    }
}

export interface IVisitResponse {
    status: string | null;
    message: string | null;
    data: Visit;
}

export class VisitType implements IVisitType {
    id!: number;
    name!: string | null;
    active!: boolean;

    constructor(data?: IVisitType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"] !== undefined ? _data["id"] : <any>null;
            this.name = _data["name"] !== undefined ? _data["name"] : <any>null;
            this.active = _data["active"] !== undefined ? _data["active"] : <any>null;
        }
    }

    static fromJS(data: any): VisitType {
        data = typeof data === 'object' ? data : {};
        let result = new VisitType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id !== undefined ? this.id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["active"] = this.active !== undefined ? this.active : <any>null;
        return data;
    }
}

export interface IVisitType {
    id: number;
    name: string | null;
    active: boolean;
}

export class VisitTypeArrayResponse implements IVisitTypeArrayResponse {
    status!: string | null;
    message!: string | null;
    data!: VisitType[] | null;

    constructor(data?: IVisitTypeArrayResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"] !== undefined ? _data["status"] : <any>null;
            this.message = _data["message"] !== undefined ? _data["message"] : <any>null;
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(VisitType.fromJS(item));
            }
            else {
                this.data = <any>null;
            }
        }
    }

    static fromJS(data: any): VisitTypeArrayResponse {
        data = typeof data === 'object' ? data : {};
        let result = new VisitTypeArrayResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status !== undefined ? this.status : <any>null;
        data["message"] = this.message !== undefined ? this.message : <any>null;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IVisitTypeArrayResponse {
    status: string | null;
    message: string | null;
    data: VisitType[] | null;
}

export class WeatherForecast implements IWeatherForecast {
    date!: Date;
    temperatureC!: number;
    readonly temperatureF!: number;
    summary!: string | null;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>null;
            this.temperatureC = _data["temperatureC"] !== undefined ? _data["temperatureC"] : <any>null;
            (<any>this).temperatureF = _data["temperatureF"] !== undefined ? _data["temperatureF"] : <any>null;
            this.summary = _data["summary"] !== undefined ? _data["summary"] : <any>null;
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>null;
        data["temperatureC"] = this.temperatureC !== undefined ? this.temperatureC : <any>null;
        data["temperatureF"] = this.temperatureF !== undefined ? this.temperatureF : <any>null;
        data["summary"] = this.summary !== undefined ? this.summary : <any>null;
        return data;
    }
}

export interface IWeatherForecast {
    date: Date;
    temperatureC: number;
    temperatureF: number;
    summary: string | null;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}